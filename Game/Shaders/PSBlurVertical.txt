// ============================================================================
// PSBlurVertical.hlsl - Vertical Gaussian Blur
// ============================================================================
// Second pass of separable Gaussian blur
// Uses fog opacity stored in alpha from horizontal pass
// ============================================================================

cbuffer BlurBuffer : register(b0)
{
    float4 screenSize;      // x = width, y = height, z = 1/width, w = 1/height
    float4 blurParams;      // x = blur strength, y = max blur radius, z/w = unused
};

Texture2D<float4> blurTempTexture : register(t0);  // Result from horizontal pass
SamplerState linearSampler : register(s0);

struct PSInput
{
    float4 position : SV_POSITION;
    float2 texcoord : TEXCOORD0;
};

// Same Gaussian weights as horizontal pass
static const int KERNEL_SIZE = 13;
static const float weights[KERNEL_SIZE] = {
    0.0044, 0.0115, 0.0257, 0.0488, 0.0786, 0.1070, 0.1225,
    0.1070, 0.0786, 0.0488, 0.0257, 0.0115, 0.0044
};
static const float offsets[KERNEL_SIZE] = {
    -6.0, -5.0, -4.0, -3.0, -2.0, -1.0, 0.0,
    1.0, 2.0, 3.0, 4.0, 5.0, 6.0
};

float4 main(PSInput input) : SV_TARGET
{
    float2 uv = input.texcoord;
    float2 texelSize = float2(screenSize.z, screenSize.w);
    
    // Get fog opacity from alpha (stored by horizontal pass)
    float4 centerSample = blurTempTexture.Sample(linearSampler, uv);
    float fogOpacity = centerSample.a;
    
    // Scale blur by fog opacity
    float blurStrength = blurParams.x * fogOpacity;
    float maxRadius = blurParams.y;
    float blurRadius = blurStrength * maxRadius;
    
    // If no blur needed, return center sample
    if (blurRadius < 0.5)
    {
        return float4(centerSample.rgb, fogOpacity);
    }
    
    float radiusScale = min(blurRadius / 6.0, 1.0);
    
    // Vertical blur
    float4 color = float4(0, 0, 0, 0);
    float totalWeight = 0.0;
    
    [unroll]
    for (int i = 0; i < KERNEL_SIZE; i++)
    {
        float offset = offsets[i] * radiusScale;
        float2 sampleUV = uv + float2(0.0, offset * texelSize.y);
        
        // Clamp to screen edges
        sampleUV = saturate(sampleUV);
        
        float weight = weights[i];
        float4 samp = blurTempTexture.Sample(linearSampler, sampleUV);
        color.rgb += samp.rgb * weight;
        totalWeight += weight;
    }
    
    color.rgb /= totalWeight;
    
    // Keep fog opacity in alpha for composite pass
    color.a = fogOpacity;
    
    return color;
}
